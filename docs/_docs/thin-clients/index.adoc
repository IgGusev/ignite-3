= Thin Clients

Thin clients are lightweight clients that connect to the cluster via a standard socket connection. It does not become a part of the cluster topology, never holds any data, and is not used as a destination for compute calculations.

== Building C++ Client

The source code of the C++ thin client comes with the Apache Ignite 3 distribution. To build it, use the following commands:


[tabs]
--
tab:Windows[]
[source,bat]
----
mkdir cmake-build-release
cd cmake-build-release
conan install .. --build=missing -s build_type=Release
cmake .. -DENABLE_TESTS=OFF
cmake --build . -j8
----

tab:Linux[]
[source,bash,subs="attributes,specialchars"]
----
mkdir cmake-build-release
cd cmake-build-release
conan install .. --build=missing -s build_type=Release -s compiler.libcxx=libstdc++11
cmake .. -DENABLE_TESTS=ON -DCMAKE_BUILD_TYPE=Release
cmake --build . -j8
----

tab:MacOS[]
[source,bash,subs="attributes,specialchars"]
----
mkdir cmake-build-release
cd cmake-build-release
conan install .. --build=missing -s build_type=Release -s compiler.libcxx=libc++
cmake .. -DENABLE_TESTS=ON -DCMAKE_BUILD_TYPE=Release
cmake --build . -j8
----

--





== Partition Awareness

In Apache Ignite 3, partition awareness is enabled automatically for all thin clients.

Data in the cluster is distributed between the nodes in a balanced manner for scalability and performance reasons. Each cluster node maintains a subset of the data, and the partition distribution map, which is used to determine the node that keeps the primary/backup copy of requested entries.

Partition awareness allows the thin client to send query requests directly to the node that owns the queried data.

Without partition awareness, an application that is connected to the cluster via a thin client would execute all queries and operations via a single server node that acts as a proxy for the incoming requests.
These operations would then be re-routed to the node that stores the data that is being requested.
This would result in a bottleneck that could prevent the application from scaling linearly.

image::images/partitionawareness01.png[Without Partition Awareness]

Notice how queries must pass through the proxy server node, where they are routed to the correct node.

With partition awareness in place, the thin client can directly route queries and operations to the primary nodes that own the data required for the queries.
This eliminates the bottleneck, allowing the application to scale more easily.

image::images/partitionawareness02.png[With Partition Awareness]




== Connecting to Cluster

To initialize a thin client, use the IgniteClient class, and provide it with the configuration:

[tabs]
--
tab:Java[]
[source, java]
----
try (IgniteClient client = IgniteClient.builder()
		.addresses("127.0.0.1:10800")
		.build()
) {
	// Your code goes here
}
----

tab:.NET[]
[source, csharp]
----
var clientCfg = new IgniteClientConfiguration
{
	Endpoints = { "127.0.0.1" }
};
using var client = await IgniteClient.StartAsync(clientCfg);
----

tab:C++[]
[source, cpp]
----
using namespace ignite;

ignite_client_configuration cfg{"127.0.0.1"};
auto client = ignite_client::start(cfg, std::chrono::seconds(5));
----

--




== Using Table API

To execute table operations on a specific table, you need to get a specific view of the table and use one of its methods. Currently, there are 4 kind of views that can be used to operate table in different ways:

* `RecordView<Tuple>` - A binary record view. It can be used to operate table tuples directly.
* `RecordView<T>` - A record view mapped to a user type. It can be used to operate table using user objects which are mapped to table tuples.
* `KeyValueView<Tuple, Tuple>` - A binary key-value view. It can be used to operate table using key and value tuples separately.
* `KeyValueView<K, V>` - A key-value view with user objects. It can be used to operate table using key and value user objects mapped to table tuples.

=== Getting a Table Instance

First, get an instance of the table. To obtain an instance of table, use the `IgniteTables.table(String)` method. This method assumes a table with the specified name exists. You can also use `IgniteTables.tables()` method to list all existing tables.


[tabs]
--
tab:Java[]
[source, java]
----
IgniteTables tableApi = client.tables();
List<Table> existingTables = tableApi.tables();
Table firstTable = existingTables.get(0);

Table myTable = tableApi.table("MY_TABLE");
----

tab:.NET[]
[source, csharp]
----
var existingTables = await Client.Tables.GetTablesAsync();
var firstTable = existingTables[0];

var myTable = await Client.Tables.GetTableAsync("MY_TABLE");
----

tab:C++[]
[source, cpp]
----
using namespace ignite;

auto table_api = client.get_tables();
std::vector<table> existing_tables = table_api.get_tables();
table first_table = existing_tables.front();

std::optional<table> my_table = table_api.get_table("MY_TABLE);
----
--

=== Basic Table Operations

Once you've got a table you need to get a specific view to choose how you want to operate table records.

==== Binary record view

[tabs]
--
tab:Java[]
[source, java]
----
RecordView<Tuple> view = table.recordView();

Tuple fullRecord = Tuple.create()
	.set("id", 42)
	.set("name", "John Doe");

view.upsert(null, fullRecord);

Tuple keyRecord = Tuple.create().set("id", 42);

Tuple resRecord = view.get(null, keyRecord);

assert resRecord.columnCount() == 2;
assert resRecord.intValue("id") == 42;
assert resRecord.stringValue("name").equals("John Doe");
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
record_view<ignite_tuple> view = table.record_binary_view();

ignite_tuple full_record{
	{"id", 42},
	{"name", "John Doe"}
};

view.upsert(nullptr, record);
std::optional<ignite_tuple> res_record = view.get(null, {"id", 42});

assert(res_record.has_value());
assert(res_record->column_count() == 2);
assert(res_record->get<std::int64_t>("id") == 42);
assert(res_record->get<std::string>("name") == "John Doe");
----

--

Record view:

[tabs]
--
tab:Java[]
[source, java]
----
protected static class Pojo {
	public long id;
	public String name;

	public Pojo() {}

	public Pojo(long id) {
		this.id = id;
	}

	public Pojo(long id, String name) {
		this.id = id;
		this.name = name;
	}
}

RecordView<Pojo> pojoView = table.recordView(Mapper.of(Pojo.class));

pojoView.upsert(null, new Pojo(42, "John Doe"));
Pojo resRecord = pojoView.get(null, new Pojo(42));

assert resRecord.id == 42;
assert resRecord.name.equals("John Doe");
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
// Record view is not yet supported in C++
----

--

Key-Value binary view:

[tabs]
--
tab:Java[]
[source, java]
----
KeyValueView<Tuple, Tuple> kvView = table.keyValueView();

Tuple key = Tuple.create().set("id", 42)
Tuple val = Tuple.create().set("name", "John Doe");

kvView.put(null, key, val);
Tuple res = kvView.get(null, key);

assert res.columnCount() == 1;
assert res.stringValue("name").equals("John Doe");
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
// Key-value binary view is not yet supported in C++
----

--


Key-Value view:

[tabs]
--
tab:Java[]
[source, java]
----
protected static class Pojo {
	public long id;
	public String name;

	public Pojo() {}

	public Pojo(long id) {
		this.id = id;
	}

	public Pojo(String name) {
		this.name = name;
	}
}

KeyValueView<Long, Pojo> pojoView =
	table.keyValueView(Mapper.of(Long.class), Mapper.of(Pojo.class));

pojoView.put(null, 42, new Pojo("John Doe"));
Pojo val = pojoView.get(null, 42);

assert val.name.equals("John Doe");
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
// Key-value view is not yet supported in C++
----

--

== Using SQL API

Apache Ignite Clients provide a SQL API to execute SQL statements. This API allows query Ignite tables using SQL.

[tabs]
--
tab:Java[]
[source, java]
----
try (Session session = client.sql().createSession()) {
	ResultSet resultSet = session.execute(null, "SELECT name from POJO where id = 42");

	SqlRow row = resultSet.next();
	assert row.stringValue(0).equals("John Doe");
}
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
// SQL API is not yet supported in C++
----

--


== Transactions

Ignite transactions API allows to perform distributed transactions when working with SQL and tables. 

[tabs]
--
tab:Java[]
[source, java]
----
protected static class Account {
	public long id;
	public long balance;

	public Account() {}

	public Account(long balance) {
		this.balance = balance;
	}
}

KeyValueView<Long, Account> accounts =
	table.keyValueView(Mapper.of(Long.class), Mapper.of(Account.class));

accounts.put(null, 42, new Account(16_000));

var tx = client.transactions().begin();

Account account = accounts.get(tx, 42);
account.balance += 500;
accounts.put(tx, 42, account);

assert accounts.get(tx, 42).balance == 16_500;

tx.rollback();

assert accounts.get(tx, 42).balance == 16_000;
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
// Transactions are not yet supported in C++
----

--


== Executing Compute Tasks

Presently, the Ignite Clients support basic compute capabilities by letting you execute those compute tasks that are already deployed in the cluster. You can either run a task across all cluster nodes or a specific cluster group. The deployment assumes that you create a JAR file with the compute tasks and add the JAR to the cluster nodes' classpath.

The example below shows how to get access to the compute APIs and execute the compute task named MyTask:

[tabs]
--
tab:Java[]
[source, java]
----
String result = client.compute().<String>execute(
	client.clusterNodes(), "MyTask", "Lorem", "ipsum", 42);
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
// Compute is not yet supported in C++
----

--