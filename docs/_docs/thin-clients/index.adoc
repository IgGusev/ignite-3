= Thin Clients

Thin clients are lightweight clients that connect to the cluster via a standard socket connection. It does not become a part of the cluster topology, never holds any data, and is not used as a destination for compute calculations.

== Building C++ Client

The source code of the C++ thin client comes with the Apache Ignite 3 distribution. To build it, use the following commands:


[tabs]
--
tab:Windows[]
[source,bat]
----
mkdir cmake-build-release
cd cmake-build-release
conan install .. --build=missing -s build_type=Release
cmake .. -DENABLE_TESTS=OFF
cmake --build . -j8
----

tab:Linux[]
[source,bash,subs="attributes,specialchars"]
----
mkdir cmake-build-release
cd cmake-build-release
conan install .. --build=missing -s build_type=Release -s compiler.libcxx=libstdc++11
cmake .. -DENABLE_TESTS=ON -DCMAKE_BUILD_TYPE=Release
cmake --build . -j8
----

tab:MacOS[]
[source,bash,subs="attributes,specialchars"]
----
mkdir cmake-build-release
cd cmake-build-release
conan install .. --build=missing -s build_type=Release -s compiler.libcxx=libc++
cmake .. -DENABLE_TESTS=ON -DCMAKE_BUILD_TYPE=Release
cmake --build . -j8
----

--





== Partition Awareness

In Apache Ignite 3, partition awareness is enabled automatically for all thin clients.

Data in the cluster is distributed between the nodes in a balanced manner for scalability and performance reasons. Each cluster node maintains a subset of the data, and the partition distribution map, which is used to determine the node that keeps the primary/backup copy of requested entries.

Partition awareness allows the thin client to send query requests directly to the node that owns the queried data.

Without partition awareness, an application that is connected to the cluster via a thin client would execute all queries and operations via a single server node that acts as a proxy for the incoming requests.
These operations would then be re-routed to the node that stores the data that is being requested.
This would result in a bottleneck that could prevent the application from scaling linearly.

image::images/partitionawareness01.png[Without Partition Awareness]

Notice how queries must pass through the proxy server node, where they are routed to the correct node.

With partition awareness in place, the thin client can directly route queries and operations to the primary nodes that own the data required for the queries.
This eliminates the bottleneck, allowing the application to scale more easily.

image::images/partitionawareness02.png[With Partition Awareness]




== Connecting to Cluster

To initialize a thin client, use the IgniteClient class, and provide it with the configuration:

[tabs]
--
tab:Java[]
[source, java]
----
try (IgniteClient client = IgniteClient.builder()
		.addresses("127.0.0.1:10800")
		.build()
) {
	// Your code goes here
}
----

tab:.NET[]
[source, csharp]
----
var clientCfg = new IgniteClientConfiguration
{
	Endpoints = { "127.0.0.1" }
};
using var client = await IgniteClient.StartAsync(clientCfg);
----

tab:C++[]
[source, cpp]
----
using namespace ignite;

ignite_client_configuration cfg{"127.0.0.1"};
auto client = ignite_client::start(cfg, std::chrono::seconds(5));
----

--




== Using Table API

To execute table operations on a specific table, you need to get a specific view of the table and use one of its methods. Currently, there are 4 kind of views that can be used to operate table in different ways:

* `RecordView<Tuple>` - A binary record view. It can be used to operate table tuples directly.
* `RecordView<T>` - A record view mapped to a user type. It can be used to operate table using user objects which are mapped to table tuples.
* `KeyValueView<Tuple, Tuple>` - A binary key-value view. It can be used to operate table using key and value tuples separately.
* `KeyValueView<K, V>` - A key-value view with user objects. It can be used to operate table using key and value user objects mapped to table tuples.

=== Getting a Table Instance

First, get an instance of the table. To obtain an instance of table, use the `IgniteTables.table(String)` method. This method assumes a table with the specified name exists. You can also use `IgniteTables.tables()` method to list all existing tables.


[tabs]
--
tab:Java[]
[source, java]
----
IgniteTables tableApi = client.tables();
List<Table> existingTables = tableApi.tables();
Table firstTable = existingTables.get(0);

Table myTable = tableApi.table("MY_TABLE");
----

tab:.NET[]
[source, csharp]
----
var existingTables = await Client.Tables.GetTablesAsync();
var firstTable = existingTables[0];

var myTable = await Client.Tables.GetTableAsync("MY_TABLE");
----

tab:C++[]
[source, cpp]
----
using namespace ignite;

auto table_api = client.get_tables();
std::vector<table> existing_tables = table_api.get_tables();
table first_table = existing_tables.front();

std::optional<table> my_table = table_api.get_table("MY_TABLE);
----
--

=== Basic Table Operations

Once you've got a table you need to get a specific view to choose how you want to operate table records.

==== Binary record view

[tabs]
--
tab:Java[]
[source, java]
----
RecordView<Tuple> view = table.recordView();

Tuple fullRecord = Tuple.create()
	.set("id", 42)
	.set("name", "John Doe");

view.upsert(null, record);

Tuple keyRecord = Tuple.create().set("id", 42);

Tuple resRecord = view.get(null, keyRecord);

assert resRecord.columnCount() == 2;
assert resRecord.intValue("id") == 42;
assert resRecord.stringValue("name") == "John Doe";
----

tab:.NET[]
[source, csharp]
----
// Contact @Pavel Tupitsyn for .NET code snippets
----

tab:C++[]
[source, cpp]
----
record_view<ignite_tuple> view = table.record_binary_view();

ignite_tuple full_record{
	{"id", 42},
	{"name", "John Doe"}
};

view.upsert(nullptr, record);
std::optional<ignite_tuple> res_record = view.get(null, {"id", 42});

assert(res_record.has_value());
assert(res_record->column_count() == 2);
assert(res_record->get<std::int64_t>("id") == 42);
assert(res_record->get<std::string>("name") == "John Doe");
----

--