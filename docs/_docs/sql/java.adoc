// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
= Java SQL API

In your Java projects, you can use the Java SQL API to execute SQL statements and getting results. Statements can be executed both synchronously and asynchronously.

== Creating Tables

Here is an example of how you can create a new table on a cluster:

[source, java]
----
IgniteSql sql = CLUSTER_NODES.get(0).sql();
Session ses = sql.createSession();
ResultSet synchRes = ses.execute(
    null,
    `CREATE TABLE SYNCH(ID INT PRIMARY KEY, VAL0 INT)`
);

CompletableFuture<AsyncResultSet> fut = ses.executeAsync(
    null,
    `CREATE TABLE ASYNCH(ID INT PRIMARY KEY, VAL0 INT)`
);

AsyncResultSet asyncRes = fut.get();

ses.closeAsync().get();
----


== Filling Tables

With Apache Ignite 3, you can fill the table by adding rows one by one, or in a batch. In both cases, you create an `INSERT` statement, and then exeute it:


[tabs]
--
tab:Single Row[]
[source, java]
----
try (Statement stmt = client.sql().createStatement("INSERT INTO CITIES (ID, NAME) VALUES (?, ?)")) {
    long rowsAdded = 0;

    try (ResultSet rs = ses.execute(null, stmt, 1, "Forest Hill")) {
        rowsAdded += rs.affectedRows();
    }
    try (ResultSet rs = ses.execute(null, stmt, 2, "Denver")) {
        rowsAdded += rs.affectedRows();
    }
    try (ResultSet rs = ses.execute(null, stmt, 3, "St. Petersburg")) {
        rowsAdded += rs.affectedRows();
    }
    //...
}
----

tab:Batch Update[]
[source, java]
----
long rowsAdded = Arrays.stream(ses.executeBatch(null,
    "INSERT INTO ACCOUNTS (ACCOUNT_ID, CITY_ID, FIRST_NAME, LAST_NAME, BALANCE) values (?, ?, ?, ?, ?)",
    BatchedArguments.of(1, 1, "John", "Doe", 1000.0d)
        .add(2, 1, "Jane", "Roe", 2000.0d)
        .add(3, 1, "Mary", "Major", 1500.0d)
        .add(4, 1, "Richard", "Miles", 1450.0d)))
        .asLongStream().sum();

System.out.println("\nAdded accounts: " + rowsAdded);
----
--

== Getting Data From Table

To get data from a table, execute a `SELECT` statement to get a set of results. You can then iterate through results to get data:

[source, java]
----
try (ResultSet rs = ses.execute(null,
        "SELECT a.FIRST_NAME, a.LAST_NAME, c.NAME FROM ACCOUNTS a "
        + "INNER JOIN CITIES c on c.ID = a.CITY_ID ORDER BY a.ACCOUNT_ID")) {
    while (rs.hasNext()) {
        SqlRow row = rs.next();
        System.out.println("    "
                            + row.stringValue(1) + ", "
                            + row.stringValue(2) + ", "
                            + row.stringValue(3));
    }
}
----


== Deleting Data

To delete data, execute the `DELETE` statement:

[source, java]
----
try (ResultSet rs = ses.execute(null, "DELETE FROM ACCOUNTS WHERE ACCOUNT_ID = ?", 1)) {
    System.out.println("\n Removed accounts: " + rs.affectedRows());
}
----

== Asynchronous Execution

If necessary, you can execute your commands asynchronously:

[source, java]
----
Statement stmt = client.sql().statementBuilder()
    .query("SELECT a.FIRST_NAME, a.LAST_NAME, c.NAME FROM ACCOUNTS a "
        + "INNER JOIN CITIES c on c.ID = a.CITY_ID ORDER BY a.ACCOUNT_ID")
    .pageSize(1)
    .build();

ses.executeAsync(null, stmt)
    .thenCompose(SqlApiExample::fetchAllRowsInto)
    .get();

stmt.close();

System.out.println("\nDropping the tables...");

ses.execute(null, "DROP TABLE ACCOUNTS").close();
ses.execute(null, "DROP TABLE CITIES").close();
----

After you execute a query, you need to get the results:

[source, java]
----
private static CompletionStage<Void> fetchAllRowsInto(AsyncResultSet resultSet) {
    //
    // Process current page.
    //
    for (var row : resultSet.currentPage()) {
        System.out.println("    "
            + row.stringValue(1) + ", "
            + row.stringValue(2) + ", "
            + row.stringValue(3));
    }

    //
    // Finish if no more data.
    //
    if (!resultSet.hasMorePages()) {
        return CompletableFuture.completedFuture(null);
    }

    //
    // Request for the next page in async way, then subscribe to the response.
    //
    return resultSet.fetchNextPage().thenCompose(SqlApiExample::fetchAllRowsInto);
}
---